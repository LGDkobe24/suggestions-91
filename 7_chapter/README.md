## 7 使用工具辅助项目开发

Python项目的开发过程，其实就是一个或多个包的开发过程，而这个开发过程又由包的安装、管理、测试和发布等多个节点构成，所以这是一个复杂的过程，使用工具进行辅助开发有利于减少流程损耗，提升生产力。

### 建议70：从PyPI安装包

PyPI全称Python Package Index，直译过来就是“Python包索引”，它是Python编程语言的软件仓库。

### 建议71：使用pip和yolk安装、管理包

### 建议72：用paster创建包

distutils标准库

pastescript是一个有着良好插件机制的命令行工具

### 建议73：理解单元测试概念

好的单元测试可以带来以下好处：
* 减少了潜在bug，提高了代码的质量。
* 大大缩减软件修复的成本。
* 为集成测试提供基本保障。

纵然单元测试有各种好处，事实却往往是“理想很丰满，现实很骨感”。实际应用中，单元测试的实践并不理想，原因是多方面的：一则管理层重视不够，根本没有把单元测试提升到和系统集成测试同样的高度；二则是迫于项目期限的压力，开发人员往往没有更多的时间来写单元测试的用例和代码；三则开发人员本身存又趋利避害的侥幸心里，他们更关注于可以工作的代码，一旦编码完成，便迫切地希望进行集成工作，因为这样进度看起来更快，同时寄希望于集成测试去发现程序中潜在的问题。

有效的单元测试应该从以下几个方面考虑：

> 1. 测试先行，遵循单元测试步骤。测试不应该是编码结束后再来考虑的事情，实际上从项目需求阶段就应该开始考虑。编写单元测试应该尽量安排在项目的早起，并且测试代码应该先于被测试的代码，这样更有利于明确需求，典型的单元测试的步骤如下：>>
>> * 创建测试计划。
>> * 编写测试用例，准备测试数据。
>> * 编写测试脚本。
>> * 编写被测试代码，在代码完成之后执行测试脚本。
>> * 修正代码缺陷，重新测试直到代码可接受为止。
> 2. 遵循单元测试基本原则。常见的原则如下：
>>
>> * 一致性。意味着1000次执行和一次执行的结果应该是一样的。
>> * 原子性。意味着单元测试的执行结果返回只有两种，True后者False，不存在部分成功、部分失败的例子。
>> * 单一职责。测试应该基于情景和行为，而不是方法。如果一个方法对应着多种行为，应该有多个测试用例；而一个行为即使对应多个防范也只能有一个测试用例。
>> * 隔离性。不能依赖于其他的测试用例以及测试执行的顺序，并且无条件逻辑依赖。单元测试所有的输入应该是确定的，防范的行为和结果应是可以预测的。
> 3. 使用单元测试框架。unittest标准库。

### 建议74：为包编写单元测试

unittest标准库。

nose测试框架。

### 建议75：利用测试驱动开发提高代码的可测性

测试驱动开发（Test Driven Development, TDD）是敏捷开发中一个非常重要的理念，它提倡在真正开始编码之前测试先行，先编写测试代码，再在其基础上通过基本迭代完成编码，并不断完善。其目的是编写可用的干净的代码。所谓可用就是能够通过测试满足基本功能需求，而干净则要求代码设计良好、可读性强、没有冗余。在软件开发过程中引入TDD能带来一系列好处，如改进的设计、可测性的增强、更松的耦合度、更强的质量信心、更低的缺陷修复代价等。

编程过程中实施测试驱动开发的一般遵循如下过程：

1. 编写部分测试用例，并运行测测试。
2. 如果测试通过，则回到测试用例编写的步骤，继续添加新的测试用例。
3. 如果测试失败，则修改代码直到通过测试。
4. 当所有测试用例编写完成并通过测试之后，再来考虑对代码进行重构。

关于测试驱动开发和提高代码可测性方面有以下几点需要说明：

* TDD只是手段而不是目的，因此在实践中尽量只验证正确的事情，并且每次仅仅验证一件事。
* 测试驱动开发本省就是一门学问，不要指望通过一个简单的例子就掌握其精髓。
* 代码的不可测性可以从以下几个方面考量：实践TDD困难；外部依赖太多；需要写很多模拟代码才能完成测试；职责太多导致功能模糊；内部状态多且没有办法取操作和维护这些状态；函数没有明显返回或者参数过多；低内聚高耦合；等等。

### 建议76：使用Pylint检查代码风格

### 建议77：进行高效的代码审查（Review）

### 建议78：将包发布到PyPI
