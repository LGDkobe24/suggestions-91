## 3 基础语法

### 建议19：有节制地使用from...import语句

Python提供了3种方式来引入外部模块：import语句、from...import...及\__import\_\_函数。

**在使用import的时候需要注意以下几点：**

> * 一般情况下尽量优先使用`import a`形式，如访问B时需要使用a.B的形式。
> * 有节制地使用`from a import B`的形式，可以直接访问B。
> * 尽量避免使用`from a import *`，因为这会污染命名空间，并且无法清晰地表示导入了哪些对象。

**Python的import机制**

> Python在初始化运行环境的时候会预先加载一批内建模块到内存中，这些模块相关的信息被存放在sys.modules中。导入sys模块后在Python解释器中输入`sys.modules.items()`便可显示所有预加载模块的相关信息。
> 当加载一个模块的时候，解释器实际上要完成以下动作：
>> 1. 在sys.modules中进行搜索看看该模块是否已经存在，如果存在，则将其导入到当前局部命名空间，加载结束。
>> 2. 如果在sys.modules中找不到对应的模块的名称，则为需要导入的模块创建一个字典对象，并将该对象信息插入sys.modules中。
>> 3. 加载前确认是否需要对模块对应的文件进行编译，如果需要则先进行编译。
>> 4. 执行动态加载，在当前模块的命名空间中执行编译后的字节码，并将其中所有的对象放入模块对应的字典中。

**以下几种情况下可以考虑使用from...import...语句**

> 1. 当只需要导入部分属性或方法时。
> 2. 模块中的这些属性和方法访问频率较高导致使用“模块名.名称”的形式进行访问过于烦琐时。
> 3. 模块的文档明确说明需要使用from...import...形式，导入的是一个包下面的子模块，且使用from...import形式能够更为简单和便利时。

### 建议20：优先使用absolute import来导入模块

### 建议21：`i+=1`不等于`++i`

Python解释器会将`++i`操作解释为`+(+i)`，其中`+`表示正数符号。

### 建议22：使用with自动关闭资源

with语句可以在代码块执行完毕后还原进入该代码块时的现场。包含有with语句的代码块的执行过程如下：

1. 计算表达式的值，返回一个上下文管理器对象。
2. 加载上下文管理器对象的`__exit__()`方法以备后用。
3. 调用上下文管理器对象的`__enter__()`方法。
4. 如果with语句中设置了目标对象，则将`__enter__()`方法的返回值赋值给目标对象。
5. 执行with中的代码块。
6. 如果步骤5中代码正常结束，调用上下文管理器对象的`__exit__()`方法，其返回值直接忽略。
7. 如果步骤5中代码执行过程中发生异常，调用上下文管理器对象的`__exit__()`方法，并将异常类型、值及traceback信息作为参数传递给`__exit__()`方法。如果`__exit__()`返回值为false，则异常会被重新抛出；如果其返回值为true，异常被挂起，程序继续执行。

with的神奇实际得益于一个称为上下文管理器（content manager）的东西，它用来创建一个运行时的环境。上下文管理器是这样一个对象：它定义程序运行时需要建立的上下文，处理程序的进入和退出，实现了上下文管理协议，及在对象中定义`__enter__()`和`__exit__()`方法。其中：

* `__enter__()`：进入运行时的上下文，返回运行时上下文相关的对象，with语句中会将这个返回值绑定到目标对象。
* `__exit__()`：退出运行时的上下文，定义在块执行之后上下文管理器应该做什么。它可以处理异常，清理想出或者处理with块中语句执行完成之后需要处理的动作。

**实际上任何实现了上下文协议的对象都可以称为一个上下文管理器。**

为了更好的辅助上下文管理，Python还提供了contextlib模块，该模块是通过Generator实现的，contextlib中的contextmanager作为装饰器来提供一种针对函数级别的上下文管理机制，可以直接作用于函数／对象而不用取关心`__enter__()`和`__exit__()`方法的具体实现。

### 建议23：使用else子句简化循环（异常处理）

* for...else...
* while...else...
* try-except-else-finally

### 建议24：遵循异常处理的几点基本原则

异常处理通常需要遵循以下几点基本原则：

1. 注意异常的粒度，不推荐在try中放入过多的代码。
2. 谨慎使用单独的except语句处理所有异常，最好能定位具体的异常。同样也不推荐使用except Exception或者except StandardError来捕获异常。
3. 注意异常捕获的顺序，在合适的层次处理异常。
4. 使用更为友好的异常信息，遵守异常参数的规范。

### 建议25：避免finally中可能发生的陷阱

当try块中发生异常的时候，如果在except语句中找不到对应的异常处理，异常将会被临时保存起来，当finally执行完毕的时候，临时保存的异常将会再次被抛出，但如果finally语句中产生了新的异常或者执行了return或者break语句，那么临时保存的异常将会丢失，从而导致异常屏蔽。

finally中的return语句会优于try中的return返回。

### 建议26：深入理解None，正确判断对象是否为空

可能曾经有人写过以下代码用来判断变量a是否为空：
    
    if a is not None:
        Do something
    else:
        Do some other thing

这样写有什么问题呢？先来了解一下Python中哪些形式的数据为空。Python中以下数据会当做空来处理：

>  * 常量None。
   * 常量False。
   * 任何形式的数值类型零，如0、0L、0.0、0j。
   * 空的序列，如''、()、[]。
   * 空的字典，如{}。
   * 当用户定义的类中定义了nonzero()方法和len()方法，并且该方法返回整数0或者发布值False的时候。
