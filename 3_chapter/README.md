## 3 基础语法

### 建议19：有节制地使用from...import语句

Python提供了3种方式来引入外部模块：import语句、from...import...及\__import\_\_函数。

**在使用import的时候需要注意以下几点：**

> * 一般情况下尽量优先使用`import a`形式，如访问B时需要使用a.B的形式。
> * 有节制地使用`from a import B`的形式，可以直接访问B。
> * 尽量避免使用`from a import *`，因为这会污染命名空间，并且无法清晰地表示导入了哪些对象。

**Python的import机制**

> Python在初始化运行环境的时候会预先加载一批内建模块到内存中，这些模块相关的信息被存放在sys.modules中。导入sys模块后在Python解释器中输入`sys.modules.items()`便可显示所有预加载模块的相关信息。
> 当加载一个模块的时候，解释器实际上要完成以下动作：
>> 1. 在sys.modules中进行搜索看看该模块是否已经存在，如果存在，则将其导入到当前局部命名空间，加载结束。
>> 2. 如果在sys.modules中找不到对应的模块的名称，则为需要导入的模块创建一个字典对象，并将该对象信息插入sys.modules中。
>> 3. 加载前确认是否需要对模块对应的文件进行编译，如果需要则先进行编译。
>> 4. 执行动态加载，在当前模块的命名空间中执行编译后的字节码，并将其中所有的对象放入模块对应的字典中。

**以下几种情况下可以考虑使用from...import...语句**

> 1. 当只需要导入部分属性或方法时。
> 2. 模块中的这些属性和方法访问频率较高导致使用“模块名.名称”的形式进行访问过于烦琐时。
> 3. 模块的文档明确说明需要使用from...import...形式，导入的是一个包下面的子模块，且使用from...import形式能够更为简单和便利时。

### 建议20：优先使用absolute import来导入模块

### 建议21：`i+=1`不等于`++i`

Python解释器会将`++i`操作解释为`+(+i)`，其中`+`表示正数符号。

### 建议22：使用with自动关闭资源

with语句可以在代码块执行完毕后还原进入该代码块时的现场。包含有with语句的代码块的执行过程如下：

1. 计算表达式的值，返回一个上下文管理器对象。
2. 加载上下文管理器对象的`__exit__()`方法以备后用。
3. 调用上下文管理器对象的`__enter__()`方法。
4. 如果with语句中设置了目标对象，则将`__enter__()`方法的返回值赋值给目标对象。
5. 执行with中的代码块。
6. 如果步骤5中代码正常结束，调用上下文管理器对象的`__exit__()`方法，其返回值直接忽略。
7. 如果步骤5中代码执行过程中发生异常，调用上下文管理器对象的`__exit__()`方法，并将异常类型、值及traceback信息作为参数传递给`__exit__()`方法。如果`__exit__()`返回值为false，则异常会被重新抛出；如果其返回值为true，异常被挂起，程序继续执行。

with的神奇实际得益于一个称为上下文管理器（content manager）的东西，它用来创建一个运行时的环境。上下文管理器是这样一个对象：它定义程序运行时需要建立的上下文，处理程序的进入和退出，实现了上下文管理协议，及在对象中定义`__enter__()`和`__exit__()`方法。其中：

* `__enter__()`：进入运行时的上下文，返回运行时上下文相关的对象，with语句中会将这个返回值绑定到目标对象。
* `__exit__()`：退出运行时的上下文，定义在块执行之后上下文管理器应该做什么。它可以处理异常，清理想出或者处理with块中语句执行完成之后需要处理的动作。

**实际上任何实现了上下文协议的对象都可以称为一个上下文管理器。**

为了更好的辅助上下文管理，Python还提供了contextlib模块，该模块是通过Generator实现的，contextlib中的contextmanager作为装饰器来提供一种针对函数级别的上下文管理机制，可以直接作用于函数／对象而不用取关心`__enter__()`和`__exit__()`方法的具体实现。

### 建议23：使用else子句简化循环（异常处理）

* for...else...
* while...else...
* try-except-else-finally

### 建议24：遵循异常处理的几点基本原则

异常处理通常需要遵循以下几点基本原则：

1. 注意异常的粒度，不推荐在try中放入过多的代码。
2. 谨慎使用单独的except语句处理所有异常，最好能定位具体的异常。同样也不推荐使用except Exception或者except StandardError来捕获异常。
3. 注意异常捕获的顺序，在合适的层次处理异常。
4. 使用更为友好的异常信息，遵守异常参数的规范。

### 建议25：避免finally中可能发生的陷阱

当try块中发生异常的时候，如果在except语句中找不到对应的异常处理，异常将会被临时保存起来，当finally执行完毕的时候，临时保存的异常将会再次被抛出，但如果finally语句中产生了新的异常或者执行了return或者break语句，那么临时保存的异常将会丢失，从而导致异常屏蔽。

finally中的return语句会优于try中的return返回。

### 建议26：深入理解None，正确判断对象是否为空

可能曾经有人写过以下代码用来判断变量a是否为空：
    
    if a is not None:
        Do something
    else:
        Do some other thing

这样写有什么问题呢？先来了解一下Python中哪些形式的数据为空。Python中以下数据会当做空来处理：

> * 常量None。
  * 常量False。
  * 任何形式的数值类型零，如0、0L、0.0、0j。
  * 空的序列，如''、()、[]。
  * 空的字典，如{}。
  * 当用户定义的类中定义了nonzero()方法和len()方法，并且该方法返回整数0或者发布值False的时候。

其中常量None的特殊性体现在它既不是0、False，也不是空字符串，它就是一个空值对象。其数据类型为NoneType，遵循单利模式，是唯一的，因而不能创建None对象。**所有赋值为None的变量都相等，并且None与任何其他非None的对象比较结果都为False。**

`__nonzero__()`方法：该内部方法用于对自身对象进行空值测试，返回0/1或True/False。如果一个对象没有定义该方法，Python将获取`__len__()`方法调用的结果来进行判断。`__len__()`返回值为0则表示为空。**如果一个类中既没有定义`__len__()`方法也没有定义`__nonzero__()`方法，该类的实例用if判断的结果都为True。**

### 建议27：连接字符串应优先使用join而不是+

分别使用join()方法和使用+操作符连接字符串，join()方法的效率要高于+操作符，特别是字符串规模较大的时候，join()方法的优势更为明显。

下面分析以下这种差别的原因：

> 当用操作符+连接字符串的时候，由于字符串是不可变对象，其工作原理实际上是这样的：如果要连接如下字符串：s1+s2+s3+......+sn，执行一次+操作便会在内存中申请一块新的内存空间，并将上一次操作的结果和本次操作的右操作数复制到新申请的内存空间，即当执行s1+s2的时候会申请一块内存，并将s1、s2复制到该内存中，依次类推。因此，在N个字符串连接的过程中，会产生N-1个中间结果，每产生一个中间结果都需要申请和复制一次内存，总共需要申请N-1此内存，从而严重影响了执行的效率。
>
> 当用join()方法连接字符串的时候，会首先计算需要申请的总的内存空间，然后一次性申请所需内存并将字符序列中的每一个元素复制到内存中去。

### 建议28：格式化字符串时尽量使用.format方式而不是%

理由如下：
* format方式在使用上较%操作符更为灵活。使用format方式时，参数的顺序与格式化的顺序不必完全相同。
* format方式可以方便地作为参数传递。
* %最终会被.format方式所代替。
* %方法在某些特殊情况下使用时需要特别小心。例如：使用%方法格式化元组。

### 建议29：区别对待可变对象和不可变对象

在函数中使用默认参数时，**默认参数在函数被调用的时候仅仅被评估一次，以后都会使用第一次评估的结果**。因此，在将可变对象作为函数默认参数的时候要特别警惕的问题，对可变对象的更改会直接影响原对象。要解决该问题，最好的方法是传入None作为默认参数，在创建对象的时候动态生成列表。具体代码如下：

    def __init__(self, name, coursse=None):
        self.name = name
        if course is None: 
            course = []
        self.course = course

### 建议30：[]、()和{}：一致的容器初始化形式

**列表解析**: `[expr for iter_item in iterable if cond_expr]`。

列表解析的使用非常灵活：

* 支持多重嵌套；
* 支持多重迭代；
* 列表解析语法中的表达式可以是简单表达式，也可以是复杂表达式，甚至是函数。
* 列表解析语法中的iterable可以是任意可迭代对象。

**元组解析**：`(expr for iter_item in iterable if cond_expr)`。
**集合解析**：`{expr for iter_item in iterable if cond_expr}`。
**字典解析**：`{expr1, expr2 for iter_item in iterable if cond_expr}`。

### 建议31：记住函数传参既不是传值也不是传引用

对于Python函数参数是传值还是传引用这个问题的答案是：都不是。正确的叫法应该是传对象后者说传对象的引用。函数参数在传递的过程中将整个对象传入，对可变对象的修改在函数外部以及内部都可见，调用者和被调用者之间共享这个对象，而对于不可变对象，由于并不能真正被修改，因此，修改往往是通过生成一个新对象然后赋值来实现的。

### 建议32：警惕默认参数潜在的问题

def在Python中是一个可执行的语句，当解释器执行def的时候，默认参数也会被计算，并存在函数的.func_defaults属性中，再次调用的时候默认参数不会重新计算。

### 建议33：慎用变长参数

Python支持可变长度的参数列表，可以通过在函数定义的时候使用`*args`和`**kwargs`这两个特殊语法来实现（args和kwargs可以替换成任意变量名）。

1. 使用`*args`来实现可变参数列表：`*args`用于接受一个包装为元组形式的参数列表来传递非关键字参数，参数个数可以任意，如下例所示。

    def sum_fun(*args):
        result = 0
        for x in args[0:]:
            reult += x
        return result
    print sum_fun(2, 4)
    print sum_fun(1, 2, 3, 4, 5)
    print sum_fun()

2. 使用`**kwargs`接受字典形式的关键字参数列表，其中字典的键值对分别表示不可变参数的参数名和值。如下例中apple表示参数名，而fruit为其对应的value，可以是一个或者多个键值对。

    def category_table(**kwargs):
        for name, value in kwargs.items():
            print '{0} is a kind of {1}'.format(name, value)
    category_table(apple = 'fruit', carrot = 'vegetable', Python = 'hello')
    category_table(BMW = 'Car')

如果一个函数中同事定义了普通参数、默认参数，以及上述两种形式的可变参数，那么使用情况又是怎样的呢？

    def set_axis(x, y, xlabel="x", ylabel="y", *args, **kwargs):
        pass

在4种不同形式的参数同时存在的情况下，会首先满足普通参数，然后是默认参数。如果剩余的参数个数能够覆盖所有的默认参数，则默认参数会使用传递时候的值。如果剩余参数个数不够，则尽最大可能满足默认参数的值。除此之外其余的参数除了键值对以外所有的参数都将作为args的可变参数，kwargs则与键值对对应。

那么，为什么要慎用可变长度参数呢？原因如下：

1. 使用过于灵活。另外变长参数可能会破坏程序的健壮性。
2. 如果一个函数的参数列表很长，虽然可以通过使用`*args`和`**kwargs`来简化函数的定义，但通常这意味着这个函数可以有更好的实现方式，应该被重构。
3. 可变长参数适合在下列情况下使用：

> * 为函数添加一个装饰器
> * 如果参数的数目不确定，可以考虑使用变长参数。如配置文件。
> * 用来实习那函数的多态或者在继承情况下子类需要调用父类的某些方法的时候。

### 建议34：深入理解str()和repe()的区别

str()和repr()的区别：

1. 两者之间的目标不同：str()主要面向用户，其目的是可读性，返回形式为用户友好性和可读性都较强的字符串类型；而repr()面向的是Python解释器，或者说开发人员，其目的是准确性，其返回值表示Python解释器内部的含义，常作为编程人员debug用途。
2. 在解释器中直接输入a时默认调用repr()函数，而`print a`则调用str()函数。
3. repr()的返回值一般可以用eval()函数来还原对象。
4. 这两个防范分别调用内建的`__str__()`和`__repr__()`方法，一般来说在类中都应该定义`__repr__()`方法，而`__str__()`方法则为可选，当可读性比准确性更为重要的时候应该考虑定义`__str__()`方法。**如果类中没有定义`__str__()`方法，则默认会使用`__repr__()`方法的结果返回对象的字符串表示形式**。

### 建议35：分清staticmethod和classmethod的适用场景

静态防范和类方法都可以通过类名.方法名或者实例.方法名的形式来访问。其中静态方法没有常规方法的特殊行为，如绑定、非绑定、隐式参数等规则，而类方法的调用使用类本身作为其隐含参数，但调用本身并不需要显示提供该参数。
