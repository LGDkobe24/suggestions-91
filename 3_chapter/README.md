## 3 基础语法

### 建议19：有节制地使用from...import语句

Python提供了3种方式来引入外部模块：import语句、from...import...及\__import\_\_函数。

**在使用import的时候需要注意以下几点：**

> * 一般情况下尽量优先使用`import a`形式，如访问B时需要使用a.B的形式。
> * 有节制地使用`from a import B`的形式，可以直接访问B。
> * 尽量避免使用`from a import *`，因为这会污染命名空间，并且无法清晰地表示导入了哪些对象。

**Python的import机制**

> Python在初始化运行环境的时候会预先加载一批内建模块到内存中，这些模块相关的信息被存放在sys.modules中。导入sys模块后在Python解释器中输入`sys.modules.items()`便可显示所有预加载模块的相关信息。
> 当加载一个模块的时候，解释器实际上要完成以下动作：
>> 1. 在sys.modules中进行搜索看看该模块是否已经存在，如果存在，则将其导入到当前局部命名空间，加载结束。
>> 2. 如果在sys.modules中找不到对应的模块的名称，则为需要导入的模块创建一个字典对象，并将该对象信息插入sys.modules中。
>> 3. 加载前确认是否需要对模块对应的文件进行编译，如果需要则先进行编译。
>> 4. 执行动态加载，在当前模块的命名空间中执行编译后的字节码，并将其中所有的对象放入模块对应的字典中。

**以下几种情况下可以考虑使用from...import...语句**

> 1. 当只需要导入部分属性或方法时。
> 2. 模块中的这些属性和方法访问频率较高导致使用“模块名.名称”的形式进行访问过于烦琐时。
> 3. 模块的文档明确说明需要使用from...import...形式，导入的是一个包下面的子模块，且使用from...import形式能够更为简单和便利时。

### 建议20：优先使用absolute import来导入模块

### 建议21：`i+=1`不等于`++i`

Python解释器会将`++i`操作解释为`+(+i)`，其中`+`表示正数符号。

### 建议22：使用with自动关闭资源

with语句可以在代码块执行完毕后还原进入该代码块时的现场。包含有with语句的代码块的执行过程如下：

1. 计算表达式的值，返回一个上下文管理器对象。
2. 加载上下文管理器对象的`__exit__()`方法以备后用。
3. 调用上下文管理器对象的`__enter__()`方法。
4. 如果with语句中设置了目标对象，则将`__enter__()`方法的返回值赋值给目标对象。
5. 执行with中的代码块。
6. 如果步骤5中代码正常结束，调用上下文管理器对象的`__exit__()`方法，其返回值直接忽略。
7. 如果步骤5中代码执行过程中发生异常，调用上下文管理器对象的`__exit__()`方法，并将异常类型、值及traceback信息作为参数传递给`__exit__()`方法。如果`__exit__()`返回值为false，则异常会被重新抛出；如果其返回值为true，异常被挂起，程序继续执行。

with的神奇实际得益于一个称为上下文管理器（content manager）的东西，它用来创建一个运行时的环境。上下文管理器是这样一个对象：它定义程序运行时需要建立的上下文，处理程序的进入和退出，实现了上下文管理协议，及在对象中定义`__enter__()`和`__exit__()`方法。其中：

* `__enter__()`：进入运行时的上下文，返回运行时上下文相关的对象，with语句中会将这个返回值绑定到目标对象。
* `__exit__()`：退出运行时的上下文，定义在块执行之后上下文管理器应该做什么。它可以处理异常，清理想出或者处理with块中语句执行完成之后需要处理的动作。

**实际上任何实现了上下文协议的对象都可以称为一个上下文管理器。**

为了更好的辅助上下文管理，Python还提供了contextlib模块，该模块是通过Generator实现的，contextlib中的contextmanager作为装饰器来提供一种针对函数级别的上下文管理机制，可以直接作用于函数／对象而不用取关心`__enter__()`和`__exit__()`方法的具体实现。

### 建议23：使用else子句简化循环（异常处理）

* for...else...
* while...else...
* try-except-else-finally

### 建议24：遵循异常处理的几点基本原则

异常处理通常需要遵循以下几点基本原则：

1. 注意异常的粒度，不推荐在try中放入过多的代码。
2. 谨慎使用单独的except语句处理所有异常，最好能定位具体的异常。同样也不推荐使用except Exception或者except StandardError来捕获异常。
3. 注意异常捕获的顺序，在合适的层次处理异常。
4. 使用更为友好的异常信息，遵守异常参数的规范。

### 建议25：避免finally中可能发生的陷阱

当try块中发生异常的时候，如果在except语句中找不到对应的异常处理，异常将会被临时保存起来，当finally执行完毕的时候，临时保存的异常将会再次被抛出，但如果finally语句中产生了新的异常或者执行了return或者break语句，那么临时保存的异常将会丢失，从而导致异常屏蔽。

finally中的return语句会优于try中的return返回。

### 建议26：深入理解None，正确判断对象是否为空

可能曾经有人写过以下代码用来判断变量a是否为空：
    
    if a is not None:
        Do something
    else:
        Do some other thing

这样写有什么问题呢？先来了解一下Python中哪些形式的数据为空。Python中以下数据会当做空来处理：

> * 常量None。
  * 常量False。
  * 任何形式的数值类型零，如0、0L、0.0、0j。
  * 空的序列，如''、()、[]。
  * 空的字典，如{}。
  * 当用户定义的类中定义了nonzero()方法和len()方法，并且该方法返回整数0或者发布值False的时候。

其中常量None的特殊性体现在它既不是0、False，也不是空字符串，它就是一个空值对象。其数据类型为NoneType，遵循单利模式，是唯一的，因而不能创建None对象。**所有赋值为None的变量都相等，并且None与任何其他非None的对象比较结果都为False。**

`__nonzero__()`方法：该内部方法用于对自身对象进行空值测试，返回0/1或True/False。如果一个对象没有定义该方法，Python将获取`__len__()`方法调用的结果来进行判断。`__len__()`返回值为0则表示为空。**如果一个类中既没有定义`__len__()`方法也没有定义`__nonzero__()`方法，该类的实例用if判断的结果都为True。**

### 建议27：连接字符串应优先使用join而不是+

分别使用join()方法和使用+操作符连接字符串，join()方法的效率要高于+操作符，特别是字符串规模较大的时候，join()方法的优势更为明显。

下面分析以下这种差别的原因：

> 当用操作符+连接字符串的时候，由于字符串是不可变对象，其工作原理实际上是这样的：如果要连接如下字符串：s1+s2+s3+......+sn，执行一次+操作便会在内存中申请一块新的内存空间，并将上一次操作的结果和本次操作的右操作数复制到新申请的内存空间，即当执行s1+s2的时候会申请一块内存，并将s1、s2复制到该内存中，依次类推。因此，在N个字符串连接的过程中，会产生N-1个中间结果，每产生一个中间结果都需要申请和复制一次内存，总共需要申请N-1此内存，从而严重影响了执行的效率。
>
> 当用join()方法连接字符串的时候，会首先计算需要申请的总的内存空间，然后一次性申请所需内存并将字符序列中的每一个元素复制到内存中去。

### 建议28：格式化字符串时尽量使用.format方式而不是%

理由如下：
* format方式在使用上较%操作符更为灵活。使用format方式时，参数的顺序与格式化的顺序不必完全相同。
* format方式可以方便地作为参数传递。
* %最终会被.format方式所代替。
* %方法在某些特殊情况下使用时需要特别小心。例如：使用%方法格式化元组。


