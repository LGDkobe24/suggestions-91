## 2 编程惯用法

### 建议8：利用assert语句来发现问题

断言（assert）在很多语言中都存在，它主要为调试程序服务，能够快速方便地检查程序的异常或者发行不恰当的输入等，可防止意想不到的情况出现。Python自1.5版本开始引入断言语句，其基本语法如下：  

    assert expression1 ["," expression2]

其中计算expression1的值会返回True或者False，当值位False的时候会引发AssertionErroe，而expression2是可选的，常用来传递具体的异常信息。

**对Python中使用断言需要说明如下：**

1. __debug__的值默认设置为True，且是只读的，在Python2.7中还无法修改该值。
2. 断言是有代价的，它会对性能产生一定的影响。对于编译型的语言，如C/C++，这也许并不那么重要，因为断言只在调试模式中启用。但Python并没有严格定义调试和发布模式之间的区别，通常禁用断言的方法是在运行脚本的时候加上`-O`标志，这种方式带来的影响是它并不优化字节码，而是忽略与断言相关的语句。  

**断言实际是被设计用来捕获用户所定义的约束的，而不是用来捕获程序本身错误的，因此使用断言需要注意一下几点：**

1. 不要滥用，这是使用断言的最基本的原则。
2. 如果Python本身的异常能够处理就不要再使用断言。
3. 不要使用断言来检查用户的输入。
4. 在函数调用后，当需要确认返回值是否合理是可以使用断言。
5. 当条件是业务逻辑继续下去的先决条件是可以使用断言。

### 建议9：数据交换值的时候不推荐使用中间变量

在Python中有更简单、更Pythonic的实现方式，代码如下：  

    >>> x, y = y, x

上面的实现方式不需要借助任何中间变量并且能够获取更好的性能。  

一般情况下Python表达式的计算顺序是从左到右，但遇到表达式赋值的时候表达式右边的操作数先于左边的操作数计算，因此表达式`expr3, expr4 = expr1, expr2`的计算顺序是`expr1, expr2 -> expr3, expr4`。因此对于表达式`x, y = y, x`，其在内存中执行的顺序如下：  

1. 先计算右边的表达式`y, x`，因此先在内存中创建元组`(y, x)`，其标示符和值分别为y、x及其对应的值，其中y和x是在初始化时已经存在于内存中的对象。
2. 计算表达式左边的值进行赋值，元组被一次分配给左边的标示符，通过解压缩，元组第一标识符（为y）分配给左边第一个元素（此时为x），元组第二个标识符（为x）分配给第二个元素（此时为y），从而达到x、y值交换的目的。

更深入一点我们从Python生成的字节码来分析。Python的字节码是一种类似汇编指令的中间语言，但是一个字节码指令并不是对应一个机器指令。我们通过dis模块来进行分析。

**dis自行查阅使用。**

### 建议10：充分利用Lazy evvaluation的特性

Lazy evaluation常被译为“延迟计算”或“惰性计算”，指的是仅仅在真正需要执行的时候才计算表达式的值。充分利用Lazy evaluation的特性带来的好处主要体现在一下两个方面：

1. **避免不必要的计算，带来性能上的提升。**
2. **节省空间，使得无限循环的数据结构成为可能。**

Lazy evaluation并不是一个很大、很新鲜的话题，但古人云“不积跬步无以至千里”，**小小的改进便能写出更为优化的代码**，何乐不为。

### 建议11：理解枚举替代实现的缺陷

在Python3.4以前并不提供枚举，于是人们充分利用Python的动态性这个特征，想出了枚举的各种替代实现方式。

1. 使用类属性。  

>     class Seasons:
          Spring = 0
          Summer = 1
          Autumn = 2
          Winter = 3

>     # 简化版本
      class Seasons:
          Spring, Summer, Autumn, Winter = range(4)

2. 借助函数。  

>     def enum(*posarg, **keysarg):
          return type("Enum", (object,), 
                      dict(zip(posarg, xrange(len(posarg))), **kwesarg))

>     Seasons = enum("Spring", "Summer", "Autumn", Winter=1)
      
3. 使用collections.namedtuple。  

>     Seasons = namedtuple('Seasons', 
                           'Spring Summer Autumn Winter')._make(range(4))

Python中枚举的替代实现方式还有很多，但是这些替代实现都有其不合理的地方。

> * 允许枚举值重复。
> * 支持无意义的操作。

Python2.7以后的版本还有另外一种替代选择——使用第三方模块`flufl.enum`，它包含两种枚举类：一种是Enum，只要保证枚举值唯一即可，对值的类型没有限制；还有一种是IntEnum，其枚举值为int型。

**Python3.4中根据PEP435的建议加入了枚举Enum，其实现主要参考了flufl.enum，但两者之间还是存在一些差别的。**
