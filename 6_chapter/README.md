## 6 内部机制

### 建议54：理解buitl-in objects

自Python2.2之后，为了弥补内建类型和古典类之间的鸿沟，引入了新式类。在新式类中，object是所有内建类型的基类，用户所定义的类可以继承自object也可以继承自内建类型。

### 建议55：`__init__()`不是构造方法

`__init__()`并不是真正意义上的构造方法，`__init__()`方法所做的工作是在类的对象创建好之后进行变量的初始化。`__new__()`方法才会真正创建实例，是类的构造方法。这两个方法都是object类中默认的方法，继承自object的新式类，如果不覆盖这两个方法将会默认调用object中对应的方法。

一般情况下覆盖`__init__()`方法就能满足大部分需求，那么在什么特殊情况下需要覆盖`__new__()`方法呢？以下有几种情况：

1. 当类继承不可变类型且默认的`__new__()`方法不能满足需求的时候；
2. 用来实现工厂模式或者单例模式或者进行元类编程的时候；
3. 作为用来初始化的`__init__()`方法在多继承的情况下，子类的`__init__()`方法如果不显式调用父类的`__init__()`方法，则父类的`__init__()`方法不会被调用。

### 建议56：理解名字查找机制

在Python中，所有所谓的变量，其实都是名字，这些名字指向一个或多个Python对象。

所有的这些名字，都存在于一个表里（又称为命名空间），一般情况下，我们称之为局部变量（locals），可以通过locals()函数调用看到。

Python的名字查找机制如下：

1. 在最内层范围内查找，一般而言，就是函数内部，即在locals()里面查找。
2. 在模块内查找，即在globals()里面找。
3. 在外层查找，即在内置模块中查找，也就是是`__builtin__`中查找。

### 建议57：为什么需要self参数

### 建议58：理解MRO与多继承

在古典类中，MRO搜索采用简单的自左至右的深度优先方法，即按照多继承申明的顺序形成继承树结构，自顶向下采用深度优先的搜索顺序，当找到所需要的属性或者方法的时候就停止搜索。

而新式类采用的是C3 MRO搜索方法。关于MRO的搜索顺序我们也可以在新式类中通过查看`__mro__`属性得到证实。

**菱形继承是我们在多继承设计的时候需要尽量避免的一个问题。**

### 建议59：理解描述符机制

### 建议60：区别`__getattr__()`和`__getattribute__()`方法

`__getattr__()`和`__getattribute__()`都可以用做实例属性的获取和拦截（注意，仅对实例属性有效，非类属性），`__getattr__()`适用于未定义的属性，即该属性在实例中以及对应的类的基类以及祖先类中都不存在，而`__getattribute__()`对于所有属性的访问都会调用该方法。

**`__getattibute__()`总会被调用，而`__getattr__()`只有在`__getattribute__()`中引发异常的情况下才会被调用。**

### 建议61：使用更为安全的property

property是用来实现属性可管理性的built-in数据类型（注意：很多地方将property称为函数，个人认为这不是很恰当的，它实际上是一种实现了`__get__()`、`__set__()`方法的类，用户也可以根据自己的需要定义个性化的property），其实质是一种特殊的数据描述符（数据描述符：如果一个对象同时定义了`__get__()`和`__set__()`方法，则称为数据描述符，如果仅定义了`__get__()`方法，则称为非数据描述符）。它和普通描述符的区别在于：普通描述符提供的是一种较为低级的控制属性访问的机制，而property是它的高级应用，它以标注库的形式提供描述符的实现。

### 建议62：掌握metaclass

什么是元类：

* 元类是关于类的类，是类的模板；
* 元类是用来控制如何创建类的，正如类是创建对象的模板一样；
* 元类的实例为类，正如类的实例为对象。

Python中一切皆对象，类也是对象，可以在运行的时候动态创建。

    def dynamic_class(name):
        if name == 'A':
            class A(object):
                pass
            return A
        else:
            class B(object):
                pass
            return B

在什么情况下会用到元类呢？有句话是这么说的：当你面临一个问题还在纠结要不要使用元类的时候，往往会有其他的更为简单的解决方案。

Python界的领袖Tim Peters曾这样说过：“元类就是深度的魔法，99%的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。
”

### 建议63：熟悉Python对象协议

Python是一门动态语言，Duck Typing的概念遍布其中，所以其中的Concept并不以类型的约束为载体，而另外使用称为协议的概念。所谓协议，类似你讲英语，我也讲英语，我们就可以交流；在Python中就是我需要调用你某个防范，你正好就有这个方法。

`__str__(), __repr__(), __int__(), __long__(), __float__(), __nonzero__()`等，统称类型转换协议。

除了类型转换协议之外，还有许多其他协议。

* 用以比较大小的协议。
* 数值类型相关的协议。基本上实现了数值类型相关的几个方法，就能够模拟数值类型了。不过还需要提到一个Python中特有的概念：反运算。
* 容器类型协议。
* 可调用对象协议。
* 与可调用对象差不多的，还有一个可哈希对象，它是通过`__hash__()`方法来支持hash()这个内置函数的。
* 描述符协议和属性交互协议，上下文管理协议。

### 建议64：利用操作符重载实现中缀语法

pipe库

### 建议65：熟悉Python的迭代器协议

所谓协议，是一种松散的约定，并没有相应的接口定义。所以迭代器协议可简单归如下：
* 实现`__iter__()`方法，返回一个迭代器；
* 实现next()方法，返回当前的元素，并指向下一个元素的位置，如果当前位置已无元素，则抛出StopIteration异常。

**itertools库**。

### 建议66：熟悉Python的生成器

### 建议67：基于生成器的协程及greenlet

协程，又称微线程和纤程等，据说源于Simula和Modula-2语言，现代编程语言基本上都支持这个特性。协程往往实现在语言的运行时库或虚拟机中，操作系统对其存在一无所知，所以又被称为用户空间线程或绿色线程。又因为大部分协程的实现是协作式而非抢占式的，需要用户自己取调度，所以通常无法利用多核，但用来执行协作式多任务非常适合。


协程虽然不能充分利用多核，但它跟异步I/O结合起来以后编写I/O密集型应用非常容易，能够在同步的代码表面下实现异步的执行，其中的代表当属将greenlet与libevent/libev结合起来的gevent程序库，它是当下最受欢迎的Python网络编程库。

### 建议68：理解GIL的局限性

GIL在Python中是一个很有争议的话题，由于它的存在，多线程编程在Python中似乎并不理想，位神噩梦这么说呢？先来了解下GIL。

**GIL**被称为全局解释器锁（Global Interpreter Lock），是Python虚拟机上用作互斥线程的一种机制，它的作用是保证任何情况下虚拟机中只会有一个线程被运行，而其他线程都处于等待GIL锁被释放的状态。

Python解释器中为什么要引入GIL呢？来思考这样一个情形：我们知道Python中对象的管理与引用计数器密切相关，当计数器变为０的时候，该对象便会被垃圾回收器回收。当撤销对一个对象的引用时，Python解释器对对象以及其计数器的管理分为以下两步：

> 1. 使引用计数值减1；
> 2. 判断该计数值是否为0，如果为0，则销毁该对象。

假设线程A和B同时引用同一个对象obj，这时obj的引用计数值为2。如果现在线程A打算撤销对obj的引用。当执行完第一步的时候，由于存在多线程调度机制，A恰好在这个关键点被挂起，而B进入执行状态。但不幸的是B也同样做了撤销对obj的引用的动作，并顺利完成了所有两个步骤，这个时候由于obj的引用技术器为0，因此对象被销毁，内存被释放。但如果此时A再次被唤醒取执行第二步操作的时候会发现已经面目全非，则其操作结果完全未知。

鉴于此，在Python解释器中引入了GIL，以保证对虚拟机内部共享资源访问的互斥性。

在Python3.2中重新实现了GIL，其实现机制主要集中在两个方面：
> * 一方面是使用固定的时间而不是固定的数量的操作指令来进行线程的强制切换；
> * 另一方面是在线程释放GIL后，开始等待，直到某个其他线程获取GIL后，再开始去尝试获取GIL，这样虽然可以避免此前获得GIL的线程，不会立即再此获取GIL，但仍然无法保证优先级高的线程优先获取GIL。

### 建议69：对象的管理与垃圾回收

Python中内存管理的方式：Python使用引用计数器的方法来管理内存中的对象，即针对每一个对象维护一个引用计数值来表示该对象当前右多少个引用。引用计数算法最明显的缺点是无法解决循环引用的问题，即两个对象相互引用。

循环引用常常会在列表、元组、字典、实例以及函数使用时出现。对于由循环引用而导致的内存泄露的情况，有没有办法进行控制和管理呢？实际上Python自带了一个gc模块，它可以用来跟踪对象的循环引用，同时回收内存垃圾。有两种方式可以出发垃圾回收：一种是通过显示地调用gc.collect()进行垃圾回收；还有一种是在创建新的对象为其分配内存的时候，检查threshold阈值，当对象的数量超过threshold的时候便自动进行垃圾回收。默认情况下阈值设为（700,10,10），并且gc的自动回收功能是开启的，这些可以通过gc.isenabled()查看。

当存在循环引用并且当这个环中存在多个析构方法时，垃圾回收器不能确定对象的析构的顺序，所以为了安全起见仍然保持这些对象不被销毁。而当环被打破时，gc在回收对象的时候便会再次自动调用`__del__()`方法。

gc模块同时支持DEBUG模式，当设置DEBUG模式之后，对于循环引用造成的内存泄露，gc并不释放内存，而是输出更为详细的诊断信息为发现内存泄露提供便利。
